package bittorrent

import (
	"context"
	"github.com/gallyamow/go-bencoder"
	"net/http"
	"net/url"
	"strconv"
)

var (
	peerID   = [20]byte{'G', 'T', 'C', 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
	peerPort = uint16(6999)
)

// Tracker is an HTTP/HTTPS service which responds to HTTP GET requests.
// The response includes a peer list that helps the client participate in the torrent.
type Tracker struct {
	peerID   [20]byte
	peerPort uint16
}

type trackerRequest struct {
	// info_hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
	// Note that the value will be a bencoded dictionary, given the definition of the info key above.
	infoHash [20]byte
	// peer_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this
	// peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should
	// probably incorporate things like process ID and perhaps a timestamp recorded at startup.
	// See peer_id below for common client encodings of this field.
	peerID [20]byte
	// port: The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
	// Clients may choose to give up if it cannot establish a port within this range.
	port uint16
	// uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
	// While not explicitly stated in the official specification, the concensus is that this should be the total number
	// of bytes uploaded.
	uploaded int64
	// downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total
	// number of bytes downloaded.
	downloaded int64
	// left: The number of bytes this client still has to download in base ten ASCII. Clarification:
	// The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
	left int64
	// compact: Setting this to 1 indicates that the client accepts a compact response.
	// The peers list is replaced by a peers string with 6 bytes per peer.
	// The first four bytes are the host (in network byte order), the last two bytes are the port
	// (again in network byte order). It should be noted that some trackers only support compact responses
	// (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response unless
	// the request contains "compact=0" (in which case they will refuse the request.)
	compact bool
	// no_peer_id: Indicates that the tracker can omit peer id field in peers dictionary.
	// This option is ignored if compact is enabled.
	noPeerID bool
	// event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
	// If not specified, then this request is one performed at regular intervals.
	event string
	// started: The first request to the tracker must include the event key with this value.
	started *int64
	// stopped: Must be sent to the tracker if the client is shutting down gracefully.
	stopped *int64
	// completed: Must be sent to the tracker when the download completes.
	// However, must not be sent if the download was already 100% complete when the client started.
	// Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
	completed *int64
	// ip: Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address.
	ip *string
	// numwant: Optional. Number of peers that the client would like to receive from the tracker.
	// This value is permitted to be zero. If omitted, typically defaults to 50 peers.
	numwant *int
	// key: Optional. An additional identification that is not shared with any other peers.
	// It is intended to allow a client to prove their identity should their IP address change.
	key *string
	// trackerid: Optional. If a previous announce contained a tracker id, it should be set here.
	trackerid *string
}

func (r trackerRequest) apply(u *url.URL) {
	qs := url.Values{}

	qs.Add("info_hash", string(r.infoHash[:]))
	qs.Add("peer_id", string(r.peerID[:]))
	qs.Add("port", strconv.Itoa(int(r.port)))
	qs.Add("uploaded", strconv.FormatInt(r.uploaded, 10))
	qs.Add("downloaded", strconv.FormatInt(r.downloaded, 10))
	qs.Add("left", strconv.FormatInt(r.left, 10))

	if r.compact {
		qs.Add("compact", "1")
	} else {
		qs.Add("compact", "0")
		if r.noPeerID {
			qs.Add("no_peer_id", "1")
		} else {
			qs.Add("no_peer_id", "0")
		}
	}

	qs.Add("event", r.event)
	if r.started != nil {
		qs.Add("started", strconv.FormatInt(*r.started, 10))
	}
	if r.stopped != nil {
		qs.Add("stopped", strconv.FormatInt(*r.stopped, 10))
	}
	if r.completed != nil {
		qs.Add("completed", strconv.FormatInt(*r.completed, 10))
	}

	if r.ip != nil {
		qs.Add("ip", *r.ip)
	}
	if r.numwant != nil {
		qs.Add("numwant", strconv.Itoa(*r.numwant))
	}
	if r.key != nil {
		qs.Add("key", *r.key)
	}
	if r.trackerid != nil {
		qs.Add("trackerid", *r.trackerid)
	}

	u.RawQuery = qs.Encode()
}

type trackerResponse struct {
	// failure reason: If present, then no other keys may be present. The value is a human-readable error message as to why the request failed (string).
	failureReason *string
	// warning message: (new, optional) Similar to failure reason, but the response still gets processed normally.
	// The warning message is shown just like an error.
	warningMessage *string
	// interval: Interval in seconds that the client should wait between sending regular requests to the tracker
	interval int
	// min interval: (optional) Minimum announce interval. If present clients must not reannounce more frequently than this.
	minInterval *int
	// tracker id: A string that the client should send back on its next announcements.
	// If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
	trackerId string
	// complete: number of peers with the entire file, i.e. seeders (integer)
	complete int
	// incomplete: number of non-seeder peers, aka "leechers" (integer)
	incomplete int
	// peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
	peers []trackerResponsePeer
	// peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string
	// consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number.
	// All in network (big endian) notation.
	// peers []byte
}

func (r trackerResponse) Parse(decoded map[string]any) trackerResponse {
	return trackerResponse{
		failureReason:  decoded["failure reason"].(*string),
		warningMessage: decoded["warning message"].(*string),
		interval:       decoded["interval"].(int),
		minInterval:    decoded["min interval"].(*int),
		trackerId:      decoded["tracker id"].(string),
		complete:       decoded["complete"].(int),
		incomplete:     decoded["incomplete"].(int),
		peers:          decoded["peers"].([]trackerResponsePeer),
	}
}

type trackerResponsePeer struct {
	// peer id: peer's self-selected ID, as described above for the tracker request (string)
	PeerID string
	// ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)
	IP string
	// port: peer's port number (integer)
	Port int
}

func (p trackerResponsePeer) Parse(decoded map[string]any) trackerResponsePeer {
	return trackerResponsePeer{
		PeerID: decoded["peer id"].(string),
		IP:     decoded["ip"].(string),
		Port:   decoded["port"].(int),
	}
}

func NewTracker() *Tracker {
	return &Tracker{peerID, peerPort}
}

// request requests peers.
// The base URL consists of the "announce URL" as defined in the metainfo (.torrent) file.
// The parameters are then added to this URL, using standard CGI methods (i.e. a '?' after the announce URL,
// followed by 'param=value' sequences separated by '&').
func (t *Tracker) request(ctx context.Context, announceURL string, request trackerRequest) (*trackerResponse, error) {
	u, err := url.Parse(announceURL)
	if err != nil {
		return nil, err
	}
	request.apply(u)

	resp, err := http.Get(u.String())
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	tmp, err := bencoder.Decode(resp.Body)
	if err != nil {
		return nil, err
	}

	decoded := tmp.(map[string]interface{})

	resp = trackerResponse{}

	return &resp, nil
}
