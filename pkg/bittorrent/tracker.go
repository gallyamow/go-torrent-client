package bittorrent

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/gallyamow/go-bencoder"
)

var (
	peerID   = [20]byte{'G', 'T', 'C', 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
	peerPort = uint16(6999)
)

func NewTracker() *Tracker {
	return &Tracker{peerID, peerPort}
}

// Tracker is an HTTP/HTTPS service which responds to HTTP GET requests.
// The response includes a peer list that helps the client participate in the torrent.
type Tracker struct {
	peerID   [20]byte
	peerPort uint16
}

// RequestAnnounce requests peers.
// The base URL consists of the "announce URL" as defined in the metainfo (.torrent) file.
// The parameters are then added to this URL, using standard CGI methods (i.e. a '?' after the announce URL,
// followed by 'param=value' sequences separated by '&').
func (t *Tracker) RequestAnnounce(ctx context.Context, tf *TorrentFile[SingleFileInfo]) (*TrackerResponse, error) {
	client := &http.Client{Timeout: 10 * time.Second}

	tr := TrackerRequest{
		InfoHash: tf.Info.Hash(),
		PeerID:   t.peerID,
		Port:     t.peerPort,
		Left:     tf.Info.Size(),
	}

	u, err := buildRequestUrl(tf.Announce, tr)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u, nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	tmp, err := bencoder.Decode(resp.Body)
	if err != nil {
		return nil, err
	}

	trackerResponse := decodeTrackerResponse(tmp.(map[string]any))

	return &trackerResponse, nil
}

type TrackerRequest struct {
	// info_hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
	// Note that the value will be a bencoded dictionary, given the definition of the info key above.
	InfoHash [20]byte
	// peer_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this
	// peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should
	// probably incorporate things like process ID and perhaps a timestamp recorded at startup.
	// See peer_id below for common client encodings of this field.
	PeerID [20]byte
	// port: The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
	// Clients may choose to give up if it cannot establish a port within this range.
	Port uint16
	// uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
	// While not explicitly stated in the official specification, the concensus is that this should be the total number
	// of bytes uploaded.
	Uploaded int64
	// downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total
	// number of bytes downloaded.
	Downloaded int64
	// left: The number of bytes this client still has to download in base ten ASCII. Clarification:
	// The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
	Left int64
	// compact: Setting this to 1 indicates that the client accepts a compact response.
	// The peers list is replaced by a peers string with 6 bytes per peer.
	// The first four bytes are the host (in network byte order), the last two bytes are the port
	// (again in network byte order). It should be noted that some trackers only support compact responses
	// (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response unless
	// the RequestAnnounce contains "compact=0" (in which case they will refuse the RequestAnnounce.)
	Compact bool
	// no_peer_id: Indicates that the tracker can omit peer id field in peers dictionary.
	// This option is ignored if compact is enabled.
	NoPeerID bool
	// event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
	// If not specified, then this RequestAnnounce is one performed at regular intervals.
	Event string
	// started: The first RequestAnnounce to the tracker must include the event key with this value.
	Started *int64
	// stopped: Must be sent to the tracker if the client is shutting down gracefully.
	Stopped *int64
	// completed: Must be sent to the tracker when the download completes.
	// However, must not be sent if the download was already 100% complete when the client started.
	// Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
	Completed *int64
	// ip: Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address.
	IP *string
	// numwant: Optional. Number of peers that the client would like to receive from the tracker.
	// This value is permitted to be zero. If omitted, typically defaults to 50 peers.
	Numwant *int
	// key: Optional. An additional identification that is not shared with any other peers.
	// It is intended to allow a client to prove their identity should their IP address change.
	Key *string
	// trackerid: Optional. If a previous announce contained a tracker id, it should be set here.
	Trackerid *string
}

func buildRequestUrl(announceURL string, r TrackerRequest) (string, error) {
	u, err := url.Parse(announceURL)
	if err != nil {
		return "", err
	}

	qs := url.Values{}

	qs.Add("info_hash", string(r.InfoHash[:]))
	qs.Add("peer_id", string(r.PeerID[:]))
	qs.Add("port", strconv.Itoa(int(r.Port)))
	qs.Add("uploaded", strconv.FormatInt(r.Uploaded, 10))
	qs.Add("downloaded", strconv.FormatInt(r.Downloaded, 10))
	qs.Add("left", strconv.FormatInt(r.Left, 10))

	if r.Compact {
		qs.Add("compact", "1")
	} else {
		qs.Add("compact", "0")
	}

	if r.NoPeerID {
		qs.Add("no_peer_id", "1")
	} else {
		qs.Add("no_peer_id", "0")
	}

	qs.Add("event", r.Event)
	if r.Started != nil {
		qs.Add("started", strconv.FormatInt(*r.Started, 10))
	}
	if r.Stopped != nil {
		qs.Add("stopped", strconv.FormatInt(*r.Stopped, 10))
	}
	if r.Completed != nil {
		qs.Add("completed", strconv.FormatInt(*r.Completed, 10))
	}

	if r.IP != nil {
		qs.Add("ip", *r.IP)
	}
	if r.Numwant != nil {
		qs.Add("numwant", strconv.Itoa(*r.Numwant))
	}
	if r.Key != nil {
		qs.Add("key", *r.Key)
	}
	if r.Trackerid != nil {
		qs.Add("trackerid", *r.Trackerid)
	}

	u.RawQuery = qs.Encode()

	return u.String(), nil
}

type TrackerResponse struct {
	// failure reason: If present, then no other keys may be present. The value is a human-readable error message as to why the RequestAnnounce failed (string).
	FailureReason *string
	// warning message: (new, optional) Similar to failure reason, but the response still gets processed normally.
	// The warning message is shown just like an error.
	WarningMessage *string
	// interval: Interval in seconds that the client should wait between sending regular requests to the tracker
	Interval int
	// min interval: (optional) Minimum announce interval. If present clients must not reannounce more frequently than this.
	MinInterval *int
	// tracker id: A string that the client should send back on its next announcements.
	// If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
	TrackerId string
	// complete: number of peers with the entire file, i.e. seeders (integer)
	Complete int
	// incomplete: number of non-seeder peers, aka "leechers" (integer)
	Incomplete int
	// peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
	Peers Peers
	// peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string
	// consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number.
	// All in network (big endian) notation.
	// peers []byte
}

func (t *TrackerResponse) String() string {
	return fmt.Sprintf("TrackerResponse{"+
		"failureReason: %s, "+
		"warningMessage: %v, "+
		"interval: %d, "+
		"minInterval: %v, "+
		"trackerId: %s, "+
		"complete: %d, "+
		"incomplete: %d, "+
		"peers: %s"+
		"}", StringifyPtr(t.FailureReason), StringifyPtr(t.WarningMessage), t.Interval, StringifyPtr(t.MinInterval), t.TrackerId, t.Complete, t.Incomplete, t.Peers.String())
}

func decodeTrackerResponse(decoded map[string]any) TrackerResponse {
	var tr TrackerResponse

	// properly handling optional fields
	if v, ok := decoded["failure reason"].(string); ok {
		tr.FailureReason = &v
	}

	if v, ok := decoded["warning message"].(string); ok {
		tr.WarningMessage = &v
	}

	if v, ok := decoded["interval"].(int64); ok {
		tr.Interval = int(v)
	}

	if v, ok := decoded["min interval"].(int64); ok {
		vi := int(v)
		tr.MinInterval = &vi
	}

	if v, ok := decoded["tracker id"].(string); ok {
		tr.TrackerId = v
	}

	if v, ok := decoded["complete"].(int64); ok {
		tr.Complete = int(v)
	}

	if v, ok := decoded["incomplete"].(int64); ok {
		tr.Incomplete = int(v)
	}

	switch v := decoded["peers"].(type) {
	case []any:
		for _, peer := range v {
			if pd, ok := peer.(map[string]any); ok {
				tr.Peers = append(tr.Peers, decodeDictPeer(pd))
			}
		}
	case string: // compact mode?
		tr.Peers = decodeBinaryPeer([]byte(v))
	}
	return tr
}
