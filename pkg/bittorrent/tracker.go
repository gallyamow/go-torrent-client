package bittorrent

import (
	"context"
	"encoding/binary"
	"github.com/gallyamow/go-bencoder"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

var (
	peerID   = [20]byte{'G', 'T', 'C', 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
	peerPort = uint16(6999)
)

func NewTracker() *Tracker {
	return &Tracker{peerID, peerPort}
}

// Tracker is an HTTP/HTTPS service which responds to HTTP GET requests.
// The response includes a peer list that helps the client participate in the torrent.
type Tracker struct {
	peerID   [20]byte
	peerPort uint16
}

// request requests peers.
// The base URL consists of the "announce URL" as defined in the metainfo (.torrent) file.
// The parameters are then added to this URL, using standard CGI methods (i.e. a '?' after the announce URL,
// followed by 'param=value' sequences separated by '&').
func (t *Tracker) request(ctx context.Context, announceURL string, request trackerRequest) (*trackerResponse, error) {
	u, err := buildRequestUrl(announceURL, request)
	if err != nil {
		return nil, err
	}

	client := &http.Client{Timeout: 10 * time.Second}

	resp, err := client.Get(u)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	tmp, err := bencoder.Decode(resp.Body)
	if err != nil {
		return nil, err
	}

	trackerResponse := decodeTrackerResponse(tmp.(map[string]any))

	return &trackerResponse, nil
}

type trackerRequest struct {
	// info_hash: urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
	// Note that the value will be a bencoded dictionary, given the definition of the info key above.
	infoHash [20]byte
	// peer_id: urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
	// This is allowed to be any value, and may be binary data. There are currently no guidelines for generating this
	// peer ID. However, one may rightly presume that it must at least be unique for your local machine, thus should
	// probably incorporate things like process ID and perhaps a timestamp recorded at startup.
	// See peer_id below for common client encodings of this field.
	peerID [20]byte
	// port: The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
	// Clients may choose to give up if it cannot establish a port within this range.
	port uint16
	// uploaded: The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
	// While not explicitly stated in the official specification, the concensus is that this should be the total number
	// of bytes uploaded.
	uploaded int64
	// downloaded: The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten
	// ASCII. While not explicitly stated in the official specification, the consensus is that this should be the total
	// number of bytes downloaded.
	downloaded int64
	// left: The number of bytes this client still has to download in base ten ASCII. Clarification:
	// The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
	left int64
	// compact: Setting this to 1 indicates that the client accepts a compact response.
	// The peers list is replaced by a peers string with 6 bytes per peer.
	// The first four bytes are the host (in network byte order), the last two bytes are the port
	// (again in network byte order). It should be noted that some trackers only support compact responses
	// (for saving bandwidth) and either refuse requests without "compact=1" or simply send a compact response unless
	// the request contains "compact=0" (in which case they will refuse the request.)
	compact bool
	// no_peer_id: Indicates that the tracker can omit peer id field in peers dictionary.
	// This option is ignored if compact is enabled.
	noPeerID bool
	// event: If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
	// If not specified, then this request is one performed at regular intervals.
	event string
	// started: The first request to the tracker must include the event key with this value.
	started *int64
	// stopped: Must be sent to the tracker if the client is shutting down gracefully.
	stopped *int64
	// completed: Must be sent to the tracker when the download completes.
	// However, must not be sent if the download was already 100% complete when the client started.
	// Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
	completed *int64
	// ip: Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address.
	ip *string
	// numwant: Optional. Number of peers that the client would like to receive from the tracker.
	// This value is permitted to be zero. If omitted, typically defaults to 50 peers.
	numwant *int
	// key: Optional. An additional identification that is not shared with any other peers.
	// It is intended to allow a client to prove their identity should their IP address change.
	key *string
	// trackerid: Optional. If a previous announce contained a tracker id, it should be set here.
	trackerid *string
}

func buildRequestUrl(announceURL string, r trackerRequest) (string, error) {
	u, err := url.Parse(announceURL)
	if err != nil {
		return "", err
	}

	qs := url.Values{}

	qs.Add("info_hash", string(r.infoHash[:]))
	qs.Add("peer_id", string(r.peerID[:]))
	qs.Add("port", strconv.Itoa(int(r.port)))
	qs.Add("uploaded", strconv.FormatInt(r.uploaded, 10))
	qs.Add("downloaded", strconv.FormatInt(r.downloaded, 10))
	qs.Add("left", strconv.FormatInt(r.left, 10))

	if r.compact {
		qs.Add("compact", "1")
	} else {
		qs.Add("compact", "0")
		if r.noPeerID {
			qs.Add("no_peer_id", "1")
		} else {
			qs.Add("no_peer_id", "0")
		}
	}

	qs.Add("event", r.event)
	if r.started != nil {
		qs.Add("started", strconv.FormatInt(*r.started, 10))
	}
	if r.stopped != nil {
		qs.Add("stopped", strconv.FormatInt(*r.stopped, 10))
	}
	if r.completed != nil {
		qs.Add("completed", strconv.FormatInt(*r.completed, 10))
	}

	if r.ip != nil {
		qs.Add("ip", *r.ip)
	}
	if r.numwant != nil {
		qs.Add("numwant", strconv.Itoa(*r.numwant))
	}
	if r.key != nil {
		qs.Add("key", *r.key)
	}
	if r.trackerid != nil {
		qs.Add("trackerid", *r.trackerid)
	}

	u.RawQuery = qs.Encode()

	return u.String(), nil
}

type trackerResponse struct {
	// failure reason: If present, then no other keys may be present. The value is a human-readable error message as to why the request failed (string).
	failureReason *string
	// warning message: (new, optional) Similar to failure reason, but the response still gets processed normally.
	// The warning message is shown just like an error.
	warningMessage *string
	// interval: Interval in seconds that the client should wait between sending regular requests to the tracker
	interval int
	// min interval: (optional) Minimum announce interval. If present clients must not reannounce more frequently than this.
	minInterval *int
	// tracker id: A string that the client should send back on its next announcements.
	// If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
	trackerId string
	// complete: number of peers with the entire file, i.e. seeders (integer)
	complete int
	// incomplete: number of non-seeder peers, aka "leechers" (integer)
	incomplete int
	// peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
	peers []trackerPeer
	// peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string
	// consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number.
	// All in network (big endian) notation.
	// peers []byte
}

func decodeTrackerResponse(decoded map[string]any) trackerResponse {
	var tr trackerResponse

	// properly handling optional fields
	if v, ok := decoded["failure reason"].(string); ok {
		tr.failureReason = &v
	}

	if v, ok := decoded["warning message"].(string); ok {
		tr.warningMessage = &v
	}

	if v, ok := decoded["interval"].(int64); ok {
		tr.interval = int(v)
	}

	if v, ok := decoded["min interval"].(int64); ok {
		vi := int(v)
		tr.minInterval = &vi
	}

	if v, ok := decoded["tracker id"].(string); ok {
		tr.trackerId = v
	}

	if v, ok := decoded["complete"].(int64); ok {
		tr.complete = int(v)
	}

	if v, ok := decoded["incomplete"].(int64); ok {
		tr.incomplete = int(v)
	}

	switch v := decoded["peers"].(type) {
	case []any:
		for _, peer := range v {
			if pd, ok := peer.(map[string]any); ok {
				tr.peers = append(tr.peers, decodeDictTrackerPeer(pd))
			}
		}
	case string: // []byte represents as string
		tr.peers = decodeBinaryTrackerPeers([]byte(v))
	}
	return tr
}

type trackerPeer struct {
	// peer id: peer's self-selected ID, as described above for the tracker request (string)
	PeerID string
	// ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)
	IP string
	// port: peer's port number (integer)
	Port int
}

func decodeDictTrackerPeer(decoded map[string]any) trackerPeer {
	var p trackerPeer

	if v, ok := decoded["peer id"].(string); ok {
		p.PeerID = v
	}
	if v, ok := decoded["ip"].(string); ok {
		p.IP = v
	}
	if v, ok := decoded["port"].(int64); ok {
		p.Port = int(v)
	}

	return p
}

func decodeBinaryTrackerPeers(data []byte) []trackerPeer {
	const peerLen = 6
	count := len(data) / peerLen
	peers := make([]trackerPeer, 0, count)

	for i := 0; i < count; i++ {
		offset := i * peerLen
		ip := net.IP(data[offset : offset+4]).String()
		port := int(binary.BigEndian.Uint16(data[offset+4 : offset+6]))
		peers = append(peers, trackerPeer{IP: ip, Port: port})
	}

	return peers
}
